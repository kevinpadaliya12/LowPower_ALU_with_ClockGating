module LowPower_ALU_with_ClockGating (
    input        clk,           
    input        rst,            
    input        enable,         
    input  [3:0] A, B,          
    input  [2:0] opcode,         
    output reg [3:0] Result,    
    output reg       Carry,     
    output reg       Zero       
);

    // Gated Clock Signal
    wire gated_clk;
    assign gated_clk = clk & enable;

    // Internal wires (same as before)
    wire [4:0] add_result = A + B;
    wire [4:0] sub_result = A - B;
    wire [3:0] and_result = A & B;
    wire [3:0] or_result  = A | B;
    wire [3:0] xor_result = A ^ B;
    wire [3:0] not_result = ~A;
    wire [3:0] shl_result = A << 1;
    wire [3:0] shr_result = A >> 1;

    reg [3:0] alu_out;
    reg       carry_out;

    // ALU logic â€“ pure combinational
    always @(*) begin
        case (opcode)
            3'b000: begin alu_out = add_result[3:0]; carry_out = add_result[4]; end
            3'b001: begin alu_out = sub_result[3:0]; carry_out = sub_result[4]; end
            3'b010: begin alu_out = and_result;      carry_out = 0;             end
            3'b011: begin alu_out = or_result;       carry_out = 0;             end
            3'b100: begin alu_out = xor_result;      carry_out = 0;             end
            3'b101: begin alu_out = not_result;      carry_out = 0;             end
            3'b110: begin alu_out = shl_result;      carry_out = 0;             end
            3'b111: begin alu_out = shr_result;      carry_out = 0;             end
            default: begin alu_out = 4'b0000;        carry_out = 0;             end
        endcase
    end

    always @(posedge gated_clk or posedge rst) begin
        if (rst) begin
            Result <= 4'b0000;
            Carry  <= 1'b0;
            Zero   <= 1'b0;
        end else begin
            Result <= alu_out;
            Carry  <= carry_out;
            Zero   <= (alu_out == 4'b0000);
        end
    end

endmodule
